//
//  TokenError.swift
//  BiscuitCrypto
//
//  Created by RÃ©mi Bardon on 09/09/2021.
//

import Foundation

/// The global error type for Biscuit
public enum TokenError: Error, CustomStringConvertible {
	
	case internalError
	case format(FormatError)
	case invalidAuthorityIndex(UInt32)
	case invalidBlockIndex(InvalidBlockIndex)
	case symbolTableOverlap
	case missingSymbols
	case sealed
	case failedLogic(LogicError)
	case parseError
	case runLimit(RunLimitError)
	case conversionError(Error)
//	case base64(base64::DecodeError)
	
	public var description: String {
		switch self {
		case .internalError:
			return "Internal error"
		case .format:
			return "Error deserializing or verifying the token"
		case .invalidAuthorityIndex:
			return "The authority block must have the index 0"
		case let .invalidBlockIndex(index):
			return "The block index does not match its position: expected \(index.expected), found \(index.found)"
		case .symbolTableOverlap:
			return "Multiple blocks declare the same symbols"
		case .missingSymbols:
			return "The symbol table is missing either \"authority\" or \"ambient\""
		case .sealed:
			return "Tried to append a block to a sealed token"
		case .failedLogic:
			return "Check validation failed"
		case .parseError:
			return "Datalog parsing error"
		case .runLimit:
			return "Reached Datalog execution limits"
		case let .conversionError(error):
			return "Cannot convert from Term: \(error)"
//		case .base64(let error):
//			return "Cannot decode base64 token: \(error)"
		}
	}
	
}

public struct InvalidBlockIndex {
	public let expected: UInt32
	public let found: UInt32
}

/// Errors related to the token's serialization format or cryptographic signature
public enum FormatError: Error, CustomStringConvertible {
	
	case signature(SignatureError)
	case sealedSignature
	case emptyKeys
	case unknownPublicKey
	case deserializationError(String)
	case serializationError(Error)
	case blockDeserializationError(String)
	case blockSerializationError(Error)
	case version(maximum: UInt32, actual: UInt32)
	case invalidKeySize(Int)
	case invalidSignatureSize(Int)
	case invalidKey(String)
	
	public var description: String {
		switch self {
		case let .signature(error):
			return "Failed verifying the signature: \(error)"
		case .sealedSignature:
			return "Failed verifying the signature of a sealed token"
		case .emptyKeys:
			return "The token does not provide intermediate public keys"
		case .unknownPublicKey:
			return "The root public key was not recognized"
		case let .deserializationError(error):
			return "Could not deserialize the wrapper object: \(error)"
		case let .serializationError(error):
			return "Could not serialize the wrapper object: \(error)"
		case let .blockDeserializationError(error):
			return "Could not deserialize the block: \(error)"
		case let .blockSerializationError(error):
			return "Could not serialize the block: \(error)"
		case let .version(maximum, actual):
			return "Block format version is higher than supported (\(actual)>\(maximum)"
		case let .invalidKeySize(size):
			return "Invalid key size: \(size)"
		case let .invalidSignatureSize(size):
			return "Invalid signature size: \(size)"
		case let .invalidKey(key):
			return "Invalid key: \(key)"
		}
	}
	
}

/// Signature errors
public enum SignatureError: Error, CustomStringConvertible {
	
	case invalidFormat
	case invalidSignature(String)
	case invalidSignatureGeneration(Error)
	
	public var description: String {
		switch self {
		case .invalidFormat:
			return "Could not parse the signature elements"
		case let .invalidSignature(error):
			return "The signature did not match: \(error)"
		case let .invalidSignatureGeneration(error):
			return "Could not sign: \(error)"
		}
	}
	
}

/// Errors in the Datalog evaluation
public enum LogicError: Error, CustomStringConvertible {
	
	case invalidAuthorityFact(String)
	case invalidAmbientFact(String)
	case invalidBlockFact(UInt32, String)
	case invalidBlockRule(UInt32, String)
	case failedChecks([FailedCheckError])
	case verifierNotEmpty
	case deny(Int)
	case noMatchingPolicy
	
	public var description: String {
		switch self {
		case let .invalidAuthorityFact(fact):
			return "A fact of the authority block did not have the authority tag: \(fact)"
		case let .invalidAmbientFact(fact):
			return "A fact provided or generated by the verifier did not have the ambient tag: \(fact)"
		case let .invalidBlockFact(index, fact):
			return "A fact provided or generated by a block had the authority or ambient tag: \(index) \(fact)"
		case let .invalidBlockRule(index, fact):
			return "A rule provided by a block is generating facts with the authority or ambient tag, or has head variables not used in its body: \(index) \(fact)"
		case let .failedChecks(errors):
			return "List of checks that failed validation: \(errors)"
		case .verifierNotEmpty:
			return "The verifier already contains a token"
		case let .deny(index):
			return "Denied by policy \(index)"
		case .noMatchingPolicy:
			return "No matching policy was found"
		}
	}
	
}

/// Check errors
public enum FailedCheckError: Error, CustomStringConvertible {
	
	// Rule = Pretty print of the rule that failed
	case block(blockId: UInt32, checkId: UInt32, rule: String)
	// Rule = Pretty print of the rule that failed
	case verifier(checkId: UInt32, rule: String)
	
	public var description: String {
		switch self {
		case let .block(blockId, checkId, rule):
			return "Check \(checkId) in block \(blockId) failed: \(rule)"
		case let .verifier(checkId, rule):
			return "Check \(checkId) provided by the verifier failed: \(rule)"
		}
	}
	
}

/// Runtime limits errors
public enum RunLimitError: Error, CustomStringConvertible {
	
	case tooManyFacts
	case tooManyIterations
	case timeout
	
	public var description: String {
		switch self {
		case .tooManyFacts:
			return "Too many facts generated"
		case .tooManyIterations:
			return "Too many engine iterations"
		case .timeout:
			return "Spent too much time verifying"
		}
	}
	
}
