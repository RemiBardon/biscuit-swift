// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: schema.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Proto_Biscuit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rootKeyID: UInt32 {
    get {return _rootKeyID ?? 0}
    set {_rootKeyID = newValue}
  }
  /// Returns true if `rootKeyID` has been explicitly set.
  public var hasRootKeyID: Bool {return self._rootKeyID != nil}
  /// Clears the value of `rootKeyID`. Subsequent reads from it will return its default value.
  public mutating func clearRootKeyID() {self._rootKeyID = nil}

  public var authority: Proto_SignedBlock {
    get {return _authority ?? Proto_SignedBlock()}
    set {_authority = newValue}
  }
  /// Returns true if `authority` has been explicitly set.
  public var hasAuthority: Bool {return self._authority != nil}
  /// Clears the value of `authority`. Subsequent reads from it will return its default value.
  public mutating func clearAuthority() {self._authority = nil}

  public var blocks: [Proto_SignedBlock] = []

  public var proof: Proto_Proof {
    get {return _proof ?? Proto_Proof()}
    set {_proof = newValue}
  }
  /// Returns true if `proof` has been explicitly set.
  public var hasProof: Bool {return self._proof != nil}
  /// Clears the value of `proof`. Subsequent reads from it will return its default value.
  public mutating func clearProof() {self._proof = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _rootKeyID: UInt32? = nil
  fileprivate var _authority: Proto_SignedBlock? = nil
  fileprivate var _proof: Proto_Proof? = nil
}

public struct Proto_SignedBlock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var block: Data {
    get {return _block ?? Data()}
    set {_block = newValue}
  }
  /// Returns true if `block` has been explicitly set.
  public var hasBlock: Bool {return self._block != nil}
  /// Clears the value of `block`. Subsequent reads from it will return its default value.
  public mutating func clearBlock() {self._block = nil}

  public var nextKey: Data {
    get {return _nextKey ?? Data()}
    set {_nextKey = newValue}
  }
  /// Returns true if `nextKey` has been explicitly set.
  public var hasNextKey: Bool {return self._nextKey != nil}
  /// Clears the value of `nextKey`. Subsequent reads from it will return its default value.
  public mutating func clearNextKey() {self._nextKey = nil}

  public var signature: Data {
    get {return _signature ?? Data()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _block: Data? = nil
  fileprivate var _nextKey: Data? = nil
  fileprivate var _signature: Data? = nil
}

public struct Proto_Proof {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var content: Proto_Proof.OneOf_Content? = nil

  public var nextSecret: Data {
    get {
      if case .nextSecret(let v)? = content {return v}
      return Data()
    }
    set {content = .nextSecret(newValue)}
  }

  public var finalSignature: Data {
    get {
      if case .finalSignature(let v)? = content {return v}
      return Data()
    }
    set {content = .finalSignature(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Content: Equatable {
    case nextSecret(Data)
    case finalSignature(Data)

  #if !swift(>=4.1)
    public static func ==(lhs: Proto_Proof.OneOf_Content, rhs: Proto_Proof.OneOf_Content) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.nextSecret, .nextSecret): return {
        guard case .nextSecret(let l) = lhs, case .nextSecret(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.finalSignature, .finalSignature): return {
        guard case .finalSignature(let l) = lhs, case .finalSignature(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Proto_Block {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var symbols: [String] = []

  public var context: String {
    get {return _context ?? String()}
    set {_context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return self._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {self._context = nil}

  public var version: UInt32 {
    get {return _version ?? 0}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  public var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  public mutating func clearVersion() {self._version = nil}

  public var factsV2: [Proto_FactV2] = []

  public var rulesV2: [Proto_RuleV2] = []

  public var checksV2: [Proto_CheckV2] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _context: String? = nil
  fileprivate var _version: UInt32? = nil
}

public struct Proto_FactV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var predicate: Proto_PredicateV2 {
    get {return _predicate ?? Proto_PredicateV2()}
    set {_predicate = newValue}
  }
  /// Returns true if `predicate` has been explicitly set.
  public var hasPredicate: Bool {return self._predicate != nil}
  /// Clears the value of `predicate`. Subsequent reads from it will return its default value.
  public mutating func clearPredicate() {self._predicate = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _predicate: Proto_PredicateV2? = nil
}

public struct Proto_RuleV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var head: Proto_PredicateV2 {
    get {return _head ?? Proto_PredicateV2()}
    set {_head = newValue}
  }
  /// Returns true if `head` has been explicitly set.
  public var hasHead: Bool {return self._head != nil}
  /// Clears the value of `head`. Subsequent reads from it will return its default value.
  public mutating func clearHead() {self._head = nil}

  public var body: [Proto_PredicateV2] = []

  public var expressions: [Proto_ExpressionV2] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _head: Proto_PredicateV2? = nil
}

public struct Proto_CheckV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var queries: [Proto_RuleV2] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_PredicateV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: UInt64 {
    get {return _name ?? 0}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {self._name = nil}

  public var ids: [Proto_IDV2] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _name: UInt64? = nil
}

public struct Proto_IDV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var content: Proto_IDV2.OneOf_Content? = nil

  public var variable: UInt32 {
    get {
      if case .variable(let v)? = content {return v}
      return 0
    }
    set {content = .variable(newValue)}
  }

  public var integer: Int64 {
    get {
      if case .integer(let v)? = content {return v}
      return 0
    }
    set {content = .integer(newValue)}
  }

  public var string: UInt64 {
    get {
      if case .string(let v)? = content {return v}
      return 0
    }
    set {content = .string(newValue)}
  }

  public var date: UInt64 {
    get {
      if case .date(let v)? = content {return v}
      return 0
    }
    set {content = .date(newValue)}
  }

  public var bytes: Data {
    get {
      if case .bytes(let v)? = content {return v}
      return Data()
    }
    set {content = .bytes(newValue)}
  }

  public var bool: Bool {
    get {
      if case .bool(let v)? = content {return v}
      return false
    }
    set {content = .bool(newValue)}
  }

  public var set: Proto_IDSet {
    get {
      if case .set(let v)? = content {return v}
      return Proto_IDSet()
    }
    set {content = .set(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Content: Equatable {
    case variable(UInt32)
    case integer(Int64)
    case string(UInt64)
    case date(UInt64)
    case bytes(Data)
    case bool(Bool)
    case set(Proto_IDSet)

  #if !swift(>=4.1)
    public static func ==(lhs: Proto_IDV2.OneOf_Content, rhs: Proto_IDV2.OneOf_Content) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.variable, .variable): return {
        guard case .variable(let l) = lhs, case .variable(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.integer, .integer): return {
        guard case .integer(let l) = lhs, case .integer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.string, .string): return {
        guard case .string(let l) = lhs, case .string(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.date, .date): return {
        guard case .date(let l) = lhs, case .date(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.bytes, .bytes): return {
        guard case .bytes(let l) = lhs, case .bytes(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.bool, .bool): return {
        guard case .bool(let l) = lhs, case .bool(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.set, .set): return {
        guard case .set(let l) = lhs, case .set(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Proto_IDSet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var set: [Proto_IDV2] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_ConstraintV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt32 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var constraint: Proto_ConstraintV2.OneOf_Constraint? = nil

  public var int: Proto_IntConstraintV2 {
    get {
      if case .int(let v)? = constraint {return v}
      return Proto_IntConstraintV2()
    }
    set {constraint = .int(newValue)}
  }

  public var string: Proto_StringConstraintV2 {
    get {
      if case .string(let v)? = constraint {return v}
      return Proto_StringConstraintV2()
    }
    set {constraint = .string(newValue)}
  }

  public var date: Proto_DateConstraintV2 {
    get {
      if case .date(let v)? = constraint {return v}
      return Proto_DateConstraintV2()
    }
    set {constraint = .date(newValue)}
  }

  public var bytes: Proto_BytesConstraintV2 {
    get {
      if case .bytes(let v)? = constraint {return v}
      return Proto_BytesConstraintV2()
    }
    set {constraint = .bytes(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Constraint: Equatable {
    case int(Proto_IntConstraintV2)
    case string(Proto_StringConstraintV2)
    case date(Proto_DateConstraintV2)
    case bytes(Proto_BytesConstraintV2)

  #if !swift(>=4.1)
    public static func ==(lhs: Proto_ConstraintV2.OneOf_Constraint, rhs: Proto_ConstraintV2.OneOf_Constraint) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.int, .int): return {
        guard case .int(let l) = lhs, case .int(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.string, .string): return {
        guard case .string(let l) = lhs, case .string(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.date, .date): return {
        guard case .date(let l) = lhs, case .date(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.bytes, .bytes): return {
        guard case .bytes(let l) = lhs, case .bytes(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _id: UInt32? = nil
}

public struct Proto_IntConstraintV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var constraint: Proto_IntConstraintV2.OneOf_Constraint? = nil

  public var lessThan: Int64 {
    get {
      if case .lessThan(let v)? = constraint {return v}
      return 0
    }
    set {constraint = .lessThan(newValue)}
  }

  public var greaterThan: Int64 {
    get {
      if case .greaterThan(let v)? = constraint {return v}
      return 0
    }
    set {constraint = .greaterThan(newValue)}
  }

  public var lessOrEqual: Int64 {
    get {
      if case .lessOrEqual(let v)? = constraint {return v}
      return 0
    }
    set {constraint = .lessOrEqual(newValue)}
  }

  public var greaterOrEqual: Int64 {
    get {
      if case .greaterOrEqual(let v)? = constraint {return v}
      return 0
    }
    set {constraint = .greaterOrEqual(newValue)}
  }

  public var equal: Int64 {
    get {
      if case .equal(let v)? = constraint {return v}
      return 0
    }
    set {constraint = .equal(newValue)}
  }

  public var inSet: Proto_IntSet {
    get {
      if case .inSet(let v)? = constraint {return v}
      return Proto_IntSet()
    }
    set {constraint = .inSet(newValue)}
  }

  public var notInSet: Proto_IntSet {
    get {
      if case .notInSet(let v)? = constraint {return v}
      return Proto_IntSet()
    }
    set {constraint = .notInSet(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Constraint: Equatable {
    case lessThan(Int64)
    case greaterThan(Int64)
    case lessOrEqual(Int64)
    case greaterOrEqual(Int64)
    case equal(Int64)
    case inSet(Proto_IntSet)
    case notInSet(Proto_IntSet)

  #if !swift(>=4.1)
    public static func ==(lhs: Proto_IntConstraintV2.OneOf_Constraint, rhs: Proto_IntConstraintV2.OneOf_Constraint) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.lessThan, .lessThan): return {
        guard case .lessThan(let l) = lhs, case .lessThan(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.greaterThan, .greaterThan): return {
        guard case .greaterThan(let l) = lhs, case .greaterThan(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.lessOrEqual, .lessOrEqual): return {
        guard case .lessOrEqual(let l) = lhs, case .lessOrEqual(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.greaterOrEqual, .greaterOrEqual): return {
        guard case .greaterOrEqual(let l) = lhs, case .greaterOrEqual(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.equal, .equal): return {
        guard case .equal(let l) = lhs, case .equal(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.inSet, .inSet): return {
        guard case .inSet(let l) = lhs, case .inSet(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.notInSet, .notInSet): return {
        guard case .notInSet(let l) = lhs, case .notInSet(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Proto_IntSet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var set: [Int64] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_StringConstraintV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var constraint: Proto_StringConstraintV2.OneOf_Constraint? = nil

  public var prefix: String {
    get {
      if case .prefix(let v)? = constraint {return v}
      return String()
    }
    set {constraint = .prefix(newValue)}
  }

  public var suffix: String {
    get {
      if case .suffix(let v)? = constraint {return v}
      return String()
    }
    set {constraint = .suffix(newValue)}
  }

  public var equal: String {
    get {
      if case .equal(let v)? = constraint {return v}
      return String()
    }
    set {constraint = .equal(newValue)}
  }

  public var inSet: Proto_StringSet {
    get {
      if case .inSet(let v)? = constraint {return v}
      return Proto_StringSet()
    }
    set {constraint = .inSet(newValue)}
  }

  public var notInSet: Proto_StringSet {
    get {
      if case .notInSet(let v)? = constraint {return v}
      return Proto_StringSet()
    }
    set {constraint = .notInSet(newValue)}
  }

  public var regex: String {
    get {
      if case .regex(let v)? = constraint {return v}
      return String()
    }
    set {constraint = .regex(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Constraint: Equatable {
    case prefix(String)
    case suffix(String)
    case equal(String)
    case inSet(Proto_StringSet)
    case notInSet(Proto_StringSet)
    case regex(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Proto_StringConstraintV2.OneOf_Constraint, rhs: Proto_StringConstraintV2.OneOf_Constraint) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.prefix, .prefix): return {
        guard case .prefix(let l) = lhs, case .prefix(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.suffix, .suffix): return {
        guard case .suffix(let l) = lhs, case .suffix(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.equal, .equal): return {
        guard case .equal(let l) = lhs, case .equal(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.inSet, .inSet): return {
        guard case .inSet(let l) = lhs, case .inSet(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.notInSet, .notInSet): return {
        guard case .notInSet(let l) = lhs, case .notInSet(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.regex, .regex): return {
        guard case .regex(let l) = lhs, case .regex(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Proto_StringSet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var set: [UInt64] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_DateConstraintV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var constraint: Proto_DateConstraintV2.OneOf_Constraint? = nil

  public var before: UInt64 {
    get {
      if case .before(let v)? = constraint {return v}
      return 0
    }
    set {constraint = .before(newValue)}
  }

  public var after: UInt64 {
    get {
      if case .after(let v)? = constraint {return v}
      return 0
    }
    set {constraint = .after(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Constraint: Equatable {
    case before(UInt64)
    case after(UInt64)

  #if !swift(>=4.1)
    public static func ==(lhs: Proto_DateConstraintV2.OneOf_Constraint, rhs: Proto_DateConstraintV2.OneOf_Constraint) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.before, .before): return {
        guard case .before(let l) = lhs, case .before(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.after, .after): return {
        guard case .after(let l) = lhs, case .after(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Proto_BytesConstraintV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var constraint: Proto_BytesConstraintV2.OneOf_Constraint? = nil

  public var equal: Data {
    get {
      if case .equal(let v)? = constraint {return v}
      return Data()
    }
    set {constraint = .equal(newValue)}
  }

  public var inSet: Proto_BytesSet {
    get {
      if case .inSet(let v)? = constraint {return v}
      return Proto_BytesSet()
    }
    set {constraint = .inSet(newValue)}
  }

  public var notInSet: Proto_BytesSet {
    get {
      if case .notInSet(let v)? = constraint {return v}
      return Proto_BytesSet()
    }
    set {constraint = .notInSet(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Constraint: Equatable {
    case equal(Data)
    case inSet(Proto_BytesSet)
    case notInSet(Proto_BytesSet)

  #if !swift(>=4.1)
    public static func ==(lhs: Proto_BytesConstraintV2.OneOf_Constraint, rhs: Proto_BytesConstraintV2.OneOf_Constraint) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.equal, .equal): return {
        guard case .equal(let l) = lhs, case .equal(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.inSet, .inSet): return {
        guard case .inSet(let l) = lhs, case .inSet(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.notInSet, .notInSet): return {
        guard case .notInSet(let l) = lhs, case .notInSet(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Proto_BytesSet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var set: [Data] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_ExpressionV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ops: [Proto_Op] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Op {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var content: Proto_Op.OneOf_Content? = nil

  public var value: Proto_IDV2 {
    get {
      if case .value(let v)? = content {return v}
      return Proto_IDV2()
    }
    set {content = .value(newValue)}
  }

  public var unary: Proto_OpUnary {
    get {
      if case .unary(let v)? = content {return v}
      return Proto_OpUnary()
    }
    set {content = .unary(newValue)}
  }

  public var binary: Proto_OpBinary {
    get {
      if case .binary(let v)? = content {return v}
      return Proto_OpBinary()
    }
    set {content = .binary(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Content: Equatable {
    case value(Proto_IDV2)
    case unary(Proto_OpUnary)
    case binary(Proto_OpBinary)

    fileprivate var isInitialized: Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch self {
      case .unary: return {
        guard case .unary(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .binary: return {
        guard case .binary(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      default: return true
      }
    }

  #if !swift(>=4.1)
    public static func ==(lhs: Proto_Op.OneOf_Content, rhs: Proto_Op.OneOf_Content) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.value, .value): return {
        guard case .value(let l) = lhs, case .value(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.unary, .unary): return {
        guard case .unary(let l) = lhs, case .unary(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.binary, .binary): return {
        guard case .binary(let l) = lhs, case .binary(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Proto_OpUnary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var kind: Proto_OpUnary.Kind {
    get {return _kind ?? .negate}
    set {_kind = newValue}
  }
  /// Returns true if `kind` has been explicitly set.
  public var hasKind: Bool {return self._kind != nil}
  /// Clears the value of `kind`. Subsequent reads from it will return its default value.
  public mutating func clearKind() {self._kind = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Kind: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case negate // = 0
    case parens // = 1
    case length // = 2

    public init() {
      self = .negate
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .negate
      case 1: self = .parens
      case 2: self = .length
      default: return nil
      }
    }

    public var rawValue: Int {
      switch self {
      case .negate: return 0
      case .parens: return 1
      case .length: return 2
      }
    }

  }

  public init() {}

  fileprivate var _kind: Proto_OpUnary.Kind? = nil
}

#if swift(>=4.2)

extension Proto_OpUnary.Kind: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public struct Proto_OpBinary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var kind: Proto_OpBinary.Kind {
    get {return _kind ?? .lessThan}
    set {_kind = newValue}
  }
  /// Returns true if `kind` has been explicitly set.
  public var hasKind: Bool {return self._kind != nil}
  /// Clears the value of `kind`. Subsequent reads from it will return its default value.
  public mutating func clearKind() {self._kind = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Kind: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case lessThan // = 0
    case greaterThan // = 1
    case lessOrEqual // = 2
    case greaterOrEqual // = 3
    case equal // = 4
    case contains // = 5
    case prefix // = 6
    case suffix // = 7
    case regex // = 8
    case add // = 9
    case sub // = 10
    case mul // = 11
    case div // = 12
    case and // = 13
    case or // = 14
    case intersection // = 15
    case union // = 16

    public init() {
      self = .lessThan
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .lessThan
      case 1: self = .greaterThan
      case 2: self = .lessOrEqual
      case 3: self = .greaterOrEqual
      case 4: self = .equal
      case 5: self = .contains
      case 6: self = .prefix
      case 7: self = .suffix
      case 8: self = .regex
      case 9: self = .add
      case 10: self = .sub
      case 11: self = .mul
      case 12: self = .div
      case 13: self = .and
      case 14: self = .or
      case 15: self = .intersection
      case 16: self = .union
      default: return nil
      }
    }

    public var rawValue: Int {
      switch self {
      case .lessThan: return 0
      case .greaterThan: return 1
      case .lessOrEqual: return 2
      case .greaterOrEqual: return 3
      case .equal: return 4
      case .contains: return 5
      case .prefix: return 6
      case .suffix: return 7
      case .regex: return 8
      case .add: return 9
      case .sub: return 10
      case .mul: return 11
      case .div: return 12
      case .and: return 13
      case .or: return 14
      case .intersection: return 15
      case .union: return 16
      }
    }

  }

  public init() {}

  fileprivate var _kind: Proto_OpBinary.Kind? = nil
}

#if swift(>=4.2)

extension Proto_OpBinary.Kind: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public struct Proto_Policy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var queries: [Proto_RuleV2] = []

  public var kind: Proto_Policy.Kind {
    get {return _kind ?? .allow}
    set {_kind = newValue}
  }
  /// Returns true if `kind` has been explicitly set.
  public var hasKind: Bool {return self._kind != nil}
  /// Clears the value of `kind`. Subsequent reads from it will return its default value.
  public mutating func clearKind() {self._kind = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Kind: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case allow // = 0
    case deny // = 1

    public init() {
      self = .allow
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .allow
      case 1: self = .deny
      default: return nil
      }
    }

    public var rawValue: Int {
      switch self {
      case .allow: return 0
      case .deny: return 1
      }
    }

  }

  public init() {}

  fileprivate var _kind: Proto_Policy.Kind? = nil
}

#if swift(>=4.2)

extension Proto_Policy.Kind: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public struct Proto_VerifierPolicies {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var symbols: [String] = []

  public var version: UInt32 {
    get {return _version ?? 0}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  public var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  public mutating func clearVersion() {self._version = nil}

  public var facts: [Proto_FactV2] = []

  public var rules: [Proto_RuleV2] = []

  public var checks: [Proto_CheckV2] = []

  public var policies: [Proto_Policy] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _version: UInt32? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto"

extension Proto_Biscuit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Biscuit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rootKeyId"),
    2: .same(proto: "authority"),
    3: .same(proto: "blocks"),
    4: .same(proto: "proof"),
  ]

  public var isInitialized: Bool {
    if self._authority == nil {return false}
    if self._proof == nil {return false}
    if let v = self._authority, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.blocks) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._rootKeyID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._authority) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.blocks) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._proof) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._rootKeyID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._authority {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.blocks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.blocks, fieldNumber: 3)
    }
    if let v = self._proof {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Biscuit, rhs: Proto_Biscuit) -> Bool {
    if lhs._rootKeyID != rhs._rootKeyID {return false}
    if lhs._authority != rhs._authority {return false}
    if lhs.blocks != rhs.blocks {return false}
    if lhs._proof != rhs._proof {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_SignedBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SignedBlock"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "block"),
    2: .same(proto: "nextKey"),
    3: .same(proto: "signature"),
  ]

  public var isInitialized: Bool {
    if self._block == nil {return false}
    if self._nextKey == nil {return false}
    if self._signature == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._block) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._nextKey) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._block {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }
    if let v = self._nextKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }
    if let v = self._signature {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_SignedBlock, rhs: Proto_SignedBlock) -> Bool {
    if lhs._block != rhs._block {return false}
    if lhs._nextKey != rhs._nextKey {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Proof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Proof"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nextSecret"),
    2: .same(proto: "finalSignature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.content != nil {try decoder.handleConflictingOneOf()}
          self.content = .nextSecret(v)
        }
      }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.content != nil {try decoder.handleConflictingOneOf()}
          self.content = .finalSignature(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.content {
    case .nextSecret?: try {
      guard case .nextSecret(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }()
    case .finalSignature?: try {
      guard case .finalSignature(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Proof, rhs: Proto_Proof) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Block: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Block"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "symbols"),
    2: .same(proto: "context"),
    3: .same(proto: "version"),
    4: .standard(proto: "facts_v2"),
    5: .standard(proto: "rules_v2"),
    6: .standard(proto: "checks_v2"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.factsV2) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.rulesV2) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.checksV2) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.symbols) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._context) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._version) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.factsV2) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.rulesV2) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.checksV2) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.symbols.isEmpty {
      try visitor.visitRepeatedStringField(value: self.symbols, fieldNumber: 1)
    }
    if let v = self._context {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._version {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    if !self.factsV2.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.factsV2, fieldNumber: 4)
    }
    if !self.rulesV2.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rulesV2, fieldNumber: 5)
    }
    if !self.checksV2.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.checksV2, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Block, rhs: Proto_Block) -> Bool {
    if lhs.symbols != rhs.symbols {return false}
    if lhs._context != rhs._context {return false}
    if lhs._version != rhs._version {return false}
    if lhs.factsV2 != rhs.factsV2 {return false}
    if lhs.rulesV2 != rhs.rulesV2 {return false}
    if lhs.checksV2 != rhs.checksV2 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_FactV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FactV2"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "predicate"),
  ]

  public var isInitialized: Bool {
    if self._predicate == nil {return false}
    if let v = self._predicate, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._predicate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._predicate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_FactV2, rhs: Proto_FactV2) -> Bool {
    if lhs._predicate != rhs._predicate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_RuleV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RuleV2"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "head"),
    2: .same(proto: "body"),
    3: .same(proto: "expressions"),
  ]

  public var isInitialized: Bool {
    if self._head == nil {return false}
    if let v = self._head, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.body) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.expressions) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._head) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.body) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.expressions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._head {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.body.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.body, fieldNumber: 2)
    }
    if !self.expressions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.expressions, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_RuleV2, rhs: Proto_RuleV2) -> Bool {
    if lhs._head != rhs._head {return false}
    if lhs.body != rhs.body {return false}
    if lhs.expressions != rhs.expressions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CheckV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CheckV2"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "queries"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.queries) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.queries) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.queries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.queries, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_CheckV2, rhs: Proto_CheckV2) -> Bool {
    if lhs.queries != rhs.queries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_PredicateV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PredicateV2"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "ids"),
  ]

  public var isInitialized: Bool {
    if self._name == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._name) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.ids) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._name {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    }
    if !self.ids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ids, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_PredicateV2, rhs: Proto_PredicateV2) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs.ids != rhs.ids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_IDV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IDV2"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "variable"),
    2: .same(proto: "integer"),
    3: .same(proto: "string"),
    4: .same(proto: "date"),
    5: .same(proto: "bytes"),
    6: .same(proto: "bool"),
    7: .same(proto: "set"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.content != nil {try decoder.handleConflictingOneOf()}
          self.content = .variable(v)
        }
      }()
      case 2: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.content != nil {try decoder.handleConflictingOneOf()}
          self.content = .integer(v)
        }
      }()
      case 3: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.content != nil {try decoder.handleConflictingOneOf()}
          self.content = .string(v)
        }
      }()
      case 4: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.content != nil {try decoder.handleConflictingOneOf()}
          self.content = .date(v)
        }
      }()
      case 5: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.content != nil {try decoder.handleConflictingOneOf()}
          self.content = .bytes(v)
        }
      }()
      case 6: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.content != nil {try decoder.handleConflictingOneOf()}
          self.content = .bool(v)
        }
      }()
      case 7: try {
        var v: Proto_IDSet?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .set(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .set(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.content {
    case .variable?: try {
      guard case .variable(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }()
    case .integer?: try {
      guard case .integer(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    }()
    case .string?: try {
      guard case .string(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    }()
    case .date?: try {
      guard case .date(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    }()
    case .bytes?: try {
      guard case .bytes(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
    }()
    case .bool?: try {
      guard case .bool(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    }()
    case .set?: try {
      guard case .set(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_IDV2, rhs: Proto_IDV2) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_IDSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IDSet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "set"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.set) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.set.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.set, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_IDSet, rhs: Proto_IDSet) -> Bool {
    if lhs.set != rhs.set {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ConstraintV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConstraintV2"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "int"),
    3: .same(proto: "string"),
    4: .same(proto: "date"),
    5: .same(proto: "bytes"),
  ]

  public var isInitialized: Bool {
    if self._id == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._id) }()
      case 2: try {
        var v: Proto_IntConstraintV2?
        var hadOneofValue = false
        if let current = self.constraint {
          hadOneofValue = true
          if case .int(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.constraint = .int(v)
        }
      }()
      case 3: try {
        var v: Proto_StringConstraintV2?
        var hadOneofValue = false
        if let current = self.constraint {
          hadOneofValue = true
          if case .string(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.constraint = .string(v)
        }
      }()
      case 4: try {
        var v: Proto_DateConstraintV2?
        var hadOneofValue = false
        if let current = self.constraint {
          hadOneofValue = true
          if case .date(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.constraint = .date(v)
        }
      }()
      case 5: try {
        var v: Proto_BytesConstraintV2?
        var hadOneofValue = false
        if let current = self.constraint {
          hadOneofValue = true
          if case .bytes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.constraint = .bytes(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._id {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.constraint {
    case .int?: try {
      guard case .int(let v)? = self.constraint else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .string?: try {
      guard case .string(let v)? = self.constraint else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .date?: try {
      guard case .date(let v)? = self.constraint else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .bytes?: try {
      guard case .bytes(let v)? = self.constraint else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_ConstraintV2, rhs: Proto_ConstraintV2) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.constraint != rhs.constraint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_IntConstraintV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IntConstraintV2"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "less_than"),
    2: .standard(proto: "greater_than"),
    3: .standard(proto: "less_or_equal"),
    4: .standard(proto: "greater_or_equal"),
    5: .same(proto: "equal"),
    6: .standard(proto: "in_set"),
    7: .standard(proto: "not_in_set"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.constraint != nil {try decoder.handleConflictingOneOf()}
          self.constraint = .lessThan(v)
        }
      }()
      case 2: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.constraint != nil {try decoder.handleConflictingOneOf()}
          self.constraint = .greaterThan(v)
        }
      }()
      case 3: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.constraint != nil {try decoder.handleConflictingOneOf()}
          self.constraint = .lessOrEqual(v)
        }
      }()
      case 4: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.constraint != nil {try decoder.handleConflictingOneOf()}
          self.constraint = .greaterOrEqual(v)
        }
      }()
      case 5: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.constraint != nil {try decoder.handleConflictingOneOf()}
          self.constraint = .equal(v)
        }
      }()
      case 6: try {
        var v: Proto_IntSet?
        var hadOneofValue = false
        if let current = self.constraint {
          hadOneofValue = true
          if case .inSet(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.constraint = .inSet(v)
        }
      }()
      case 7: try {
        var v: Proto_IntSet?
        var hadOneofValue = false
        if let current = self.constraint {
          hadOneofValue = true
          if case .notInSet(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.constraint = .notInSet(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.constraint {
    case .lessThan?: try {
      guard case .lessThan(let v)? = self.constraint else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    }()
    case .greaterThan?: try {
      guard case .greaterThan(let v)? = self.constraint else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    }()
    case .lessOrEqual?: try {
      guard case .lessOrEqual(let v)? = self.constraint else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    }()
    case .greaterOrEqual?: try {
      guard case .greaterOrEqual(let v)? = self.constraint else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
    }()
    case .equal?: try {
      guard case .equal(let v)? = self.constraint else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 5)
    }()
    case .inSet?: try {
      guard case .inSet(let v)? = self.constraint else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .notInSet?: try {
      guard case .notInSet(let v)? = self.constraint else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_IntConstraintV2, rhs: Proto_IntConstraintV2) -> Bool {
    if lhs.constraint != rhs.constraint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_IntSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IntSet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    7: .same(proto: "set"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 7: try { try decoder.decodeRepeatedInt64Field(value: &self.set) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.set.isEmpty {
      try visitor.visitPackedInt64Field(value: self.set, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_IntSet, rhs: Proto_IntSet) -> Bool {
    if lhs.set != rhs.set {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_StringConstraintV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StringConstraintV2"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "prefix"),
    2: .same(proto: "suffix"),
    3: .same(proto: "equal"),
    4: .standard(proto: "in_set"),
    5: .standard(proto: "not_in_set"),
    6: .same(proto: "regex"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.constraint != nil {try decoder.handleConflictingOneOf()}
          self.constraint = .prefix(v)
        }
      }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.constraint != nil {try decoder.handleConflictingOneOf()}
          self.constraint = .suffix(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.constraint != nil {try decoder.handleConflictingOneOf()}
          self.constraint = .equal(v)
        }
      }()
      case 4: try {
        var v: Proto_StringSet?
        var hadOneofValue = false
        if let current = self.constraint {
          hadOneofValue = true
          if case .inSet(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.constraint = .inSet(v)
        }
      }()
      case 5: try {
        var v: Proto_StringSet?
        var hadOneofValue = false
        if let current = self.constraint {
          hadOneofValue = true
          if case .notInSet(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.constraint = .notInSet(v)
        }
      }()
      case 6: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.constraint != nil {try decoder.handleConflictingOneOf()}
          self.constraint = .regex(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.constraint {
    case .prefix?: try {
      guard case .prefix(let v)? = self.constraint else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .suffix?: try {
      guard case .suffix(let v)? = self.constraint else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .equal?: try {
      guard case .equal(let v)? = self.constraint else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case .inSet?: try {
      guard case .inSet(let v)? = self.constraint else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .notInSet?: try {
      guard case .notInSet(let v)? = self.constraint else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .regex?: try {
      guard case .regex(let v)? = self.constraint else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_StringConstraintV2, rhs: Proto_StringConstraintV2) -> Bool {
    if lhs.constraint != rhs.constraint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_StringSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StringSet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "set"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt64Field(value: &self.set) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.set.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.set, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_StringSet, rhs: Proto_StringSet) -> Bool {
    if lhs.set != rhs.set {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_DateConstraintV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DateConstraintV2"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "before"),
    2: .same(proto: "after"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.constraint != nil {try decoder.handleConflictingOneOf()}
          self.constraint = .before(v)
        }
      }()
      case 2: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.constraint != nil {try decoder.handleConflictingOneOf()}
          self.constraint = .after(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.constraint {
    case .before?: try {
      guard case .before(let v)? = self.constraint else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    }()
    case .after?: try {
      guard case .after(let v)? = self.constraint else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_DateConstraintV2, rhs: Proto_DateConstraintV2) -> Bool {
    if lhs.constraint != rhs.constraint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_BytesConstraintV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BytesConstraintV2"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "equal"),
    2: .standard(proto: "in_set"),
    3: .standard(proto: "not_in_set"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.constraint != nil {try decoder.handleConflictingOneOf()}
          self.constraint = .equal(v)
        }
      }()
      case 2: try {
        var v: Proto_BytesSet?
        var hadOneofValue = false
        if let current = self.constraint {
          hadOneofValue = true
          if case .inSet(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.constraint = .inSet(v)
        }
      }()
      case 3: try {
        var v: Proto_BytesSet?
        var hadOneofValue = false
        if let current = self.constraint {
          hadOneofValue = true
          if case .notInSet(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.constraint = .notInSet(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.constraint {
    case .equal?: try {
      guard case .equal(let v)? = self.constraint else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }()
    case .inSet?: try {
      guard case .inSet(let v)? = self.constraint else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .notInSet?: try {
      guard case .notInSet(let v)? = self.constraint else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_BytesConstraintV2, rhs: Proto_BytesConstraintV2) -> Bool {
    if lhs.constraint != rhs.constraint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_BytesSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BytesSet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "set"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.set) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.set.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.set, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_BytesSet, rhs: Proto_BytesSet) -> Bool {
    if lhs.set != rhs.set {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ExpressionV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExpressionV2"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ops"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.ops) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.ops) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ops.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ops, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_ExpressionV2, rhs: Proto_ExpressionV2) -> Bool {
    if lhs.ops != rhs.ops {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Op: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Op"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "unary"),
    3: .same(proto: "Binary"),
  ]

  public var isInitialized: Bool {
    if let v = self.content, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Proto_IDV2?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .value(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .value(v)
        }
      }()
      case 2: try {
        var v: Proto_OpUnary?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .unary(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .unary(v)
        }
      }()
      case 3: try {
        var v: Proto_OpBinary?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .binary(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .binary(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.content {
    case .value?: try {
      guard case .value(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .unary?: try {
      guard case .unary(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .binary?: try {
      guard case .binary(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Op, rhs: Proto_Op) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_OpUnary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OpUnary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
  ]

  public var isInitialized: Bool {
    if self._kind == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._kind) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._kind {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_OpUnary, rhs: Proto_OpUnary) -> Bool {
    if lhs._kind != rhs._kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_OpUnary.Kind: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Negate"),
    1: .same(proto: "Parens"),
    2: .same(proto: "Length"),
  ]
}

extension Proto_OpBinary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OpBinary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
  ]

  public var isInitialized: Bool {
    if self._kind == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._kind) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._kind {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_OpBinary, rhs: Proto_OpBinary) -> Bool {
    if lhs._kind != rhs._kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_OpBinary.Kind: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LessThan"),
    1: .same(proto: "GreaterThan"),
    2: .same(proto: "LessOrEqual"),
    3: .same(proto: "GreaterOrEqual"),
    4: .same(proto: "Equal"),
    5: .same(proto: "Contains"),
    6: .same(proto: "Prefix"),
    7: .same(proto: "Suffix"),
    8: .same(proto: "Regex"),
    9: .same(proto: "Add"),
    10: .same(proto: "Sub"),
    11: .same(proto: "Mul"),
    12: .same(proto: "Div"),
    13: .same(proto: "And"),
    14: .same(proto: "Or"),
    15: .same(proto: "Intersection"),
    16: .same(proto: "Union"),
  ]
}

extension Proto_Policy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Policy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "queries"),
    2: .same(proto: "kind"),
  ]

  public var isInitialized: Bool {
    if self._kind == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.queries) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.queries) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._kind) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.queries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.queries, fieldNumber: 1)
    }
    if let v = self._kind {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Policy, rhs: Proto_Policy) -> Bool {
    if lhs.queries != rhs.queries {return false}
    if lhs._kind != rhs._kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Policy.Kind: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Allow"),
    1: .same(proto: "Deny"),
  ]
}

extension Proto_VerifierPolicies: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VerifierPolicies"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "symbols"),
    2: .same(proto: "version"),
    3: .same(proto: "facts"),
    4: .same(proto: "rules"),
    5: .same(proto: "checks"),
    6: .same(proto: "policies"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.facts) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.rules) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.checks) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.policies) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.symbols) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._version) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.facts) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.rules) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.checks) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.policies) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.symbols.isEmpty {
      try visitor.visitRepeatedStringField(value: self.symbols, fieldNumber: 1)
    }
    if let v = self._version {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if !self.facts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.facts, fieldNumber: 3)
    }
    if !self.rules.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rules, fieldNumber: 4)
    }
    if !self.checks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.checks, fieldNumber: 5)
    }
    if !self.policies.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.policies, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_VerifierPolicies, rhs: Proto_VerifierPolicies) -> Bool {
    if lhs.symbols != rhs.symbols {return false}
    if lhs._version != rhs._version {return false}
    if lhs.facts != rhs.facts {return false}
    if lhs.rules != rhs.rules {return false}
    if lhs.checks != rhs.checks {return false}
    if lhs.policies != rhs.policies {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
